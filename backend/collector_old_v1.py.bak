#!/usr/bin/env python3
"""
Steam 游戏时长数据采集器 V2 - 基于网页爬虫
从 Steam 个人主页爬取"最新动态"的游戏数据
"""

import os
import json
import logging
from datetime import datetime
from typing import List, Dict, Any, Optional
import psycopg2
from psycopg2.extras import Json, RealDictCursor
from dotenv import load_dotenv
import toml

from steam_scraper import SteamProfileScraper

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class SteamCollectorV2:
    """Steam 游戏数据采集器 V2 - 基于爬虫"""
    
    def __init__(self, db_url: str):
        """
        初始化采集器
        
        Args:
            db_url: PostgreSQL 数据库连接字符串
        """
        self.db_url = db_url
        self.conn = None
        self.scraper = SteamProfileScraper()
        
    def connect_db(self):
        """连接数据库"""
        try:
            self.conn = psycopg2.connect(self.db_url)
            logger.info("数据库连接成功")
        except Exception as e:
            logger.error(f"数据库连接失败: {e}")
            raise
    
    def close_db(self):
        """关闭数据库连接"""
        if self.conn:
            self.conn.close()
            logger.info("数据库连接已关闭")
    
    def get_last_snapshot(self, player_id: str) -> Optional[Dict[str, Any]]:
        """
        获取指定玩家的最后一次快照
        
        Args:
            player_id: 玩家 Steam ID
            
        Returns:
            最后一次快照数据，如果不存在返回 None
        """
        try:
            cursor = self.conn.cursor(cursor_factory=RealDictCursor)
            cursor.execute(
                """
                SELECT games_data 
                FROM game_snapshots 
                WHERE player_id = %s 
                ORDER BY snapshot_time DESC 
                LIMIT 1
                """,
                (player_id,)
            )
            result = cursor.fetchone()
            cursor.close()
            
            if result:
                return result['games_data']
            return None
            
        except Exception as e:
            logger.error(f"查询最后快照失败: {e}")
            return None
    
    def is_data_changed(self, old_data: Optional[Dict], new_data: List[Dict]) -> bool:
        """
        比较两次快照数据是否有变化
        
        现在只关注最近3个游戏的总时数变化
        
        Args:
            old_data: 上次快照数据（完整的 games_data 对象）
            new_data: 本次爬取的游戏列表
            
        Returns:
            True 表示数据有变化，False 表示无变化
        """
        if old_data is None:
            return True  # 第一次采集，必然保存
        
        # 从旧数据中提取游戏列表
        old_games = old_data.get('recent_games', []) if isinstance(old_data, dict) else []
        
        if len(old_games) != len(new_data):
            return True
        
        # 比较每个游戏的总时数
        # 创建字典方便查找
        old_games_dict = {game['appid']: game for game in old_games}
        
        for new_game in new_data:
            appid = new_game.get('appid')
            if not appid:
                continue
            
            old_game = old_games_dict.get(appid)
            if not old_game:
                # 新增游戏
                return True
            
            # 比较总时数（允许小误差，防止浮点数问题）
            old_time = old_game.get('playtime_total', 0)
            new_time = new_game.get('playtime_total', 0)
            
            if abs(old_time - new_time) > 0.01:  # 差异超过0.01小时才算变化
                return True
        
        return False
    
    def save_snapshot(self, player_id: str, player_name: str, games_data: List[Dict[str, Any]]) -> bool:
        """
        保存快照到数据库
        
        Args:
            player_id: 玩家 Steam ID
            player_name: 玩家名称
            games_data: 游戏列表（最近3个游戏）
            
        Returns:
            保存成功返回 True，失败返回 False
        """
        try:
            cursor = self.conn.cursor()
            
            # 构造要保存的数据结构
            snapshot_data = {
                'data_source': 'web_scraper',  # 标记数据来源
                'game_count': len(games_data),
                'recent_games': games_data  # 最近玩过的游戏
            }
            
            cursor.execute(
                """
                INSERT INTO game_snapshots (player_id, player_name, snapshot_time, games_data)
                VALUES (%s, %s, %s, %s)
                """,
                (player_id, player_name, datetime.now(), Json(snapshot_data))
            )
            self.conn.commit()
            cursor.close()
            logger.info(f"成功保存玩家 {player_id} 的快照（{len(games_data)} 个游戏）")
            return True
            
        except Exception as e:
            logger.error(f"保存快照失败: {e}")
            self.conn.rollback()
            return False
    
    def collect_player_data(self, steamid: str, vanity_url: Optional[str] = None):
        """
        采集单个玩家的数据
        
        Args:
            steamid: 玩家的 Steam ID
            vanity_url: 玩家的个性化 URL（可选）
        """
        logger.info(f"开始采集玩家数据: {steamid}")
        
        # 爬取游戏数据
        games_data = self.scraper.scrape_recent_games(steamid, vanity_url)
        if not games_data:
            logger.warning(f"无法获取玩家 {steamid} 的游戏数据，可能是账号私密或网络问题")
            return
        
        # 获取玩家名称
        player_name = self.scraper.get_player_name(steamid, vanity_url)
        if not player_name:
            player_name = vanity_url or steamid
        
        # 检查数据是否有变化
        last_snapshot = self.get_last_snapshot(steamid)
        if not self.is_data_changed(last_snapshot, games_data):
            logger.info(f"玩家 {steamid} 的数据无变化，跳过保存")
            return
        
        # 保存快照
        self.save_snapshot(steamid, player_name, games_data)
        
        logger.info(f"玩家 {player_name} ({steamid}) 最近玩了 {len(games_data)} 个游戏")
        for game in games_data:
            logger.info(f"  - {game['game_name']}: {game.get('playtime_total', 0)} 小时")


def load_config():
    """加载配置文件"""
    config_path = os.path.join(os.path.dirname(__file__), '..', 'config.toml')
    if not os.path.exists(config_path):
        logger.error(f"配置文件不存在: {config_path}")
        return None
    
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            config = toml.load(f)
        return config
    except Exception as e:
        logger.error(f"加载配置文件失败: {e}")
        return None


def main():
    """主函数"""
    # 加载环境变量
    env_path = os.path.join(os.path.dirname(__file__), '.env')
    if os.path.exists(env_path):
        load_dotenv(env_path)
    else:
        logger.warning(".env 文件不存在，尝试从环境变量读取配置")
    
    # 获取配置
    db_url = os.getenv('DATABASE_URL')
    
    if not db_url:
        logger.error("未配置 DATABASE_URL 环境变量")
        return
    
    # 加载玩家配置
    config = load_config()
    if not config:
        return
    
    players = config.get('steam', {}).get('players', [])
    if not players:
        logger.error("配置文件中未找到玩家信息")
        return
    
    # 初始化采集器
    collector = SteamCollectorV2(db_url)
    
    try:
        # 连接数据库
        collector.connect_db()
        
        # 采集每个玩家的数据
        for player in players:
            steamid = player.get('steamid')
            vanity_url = player.get('vanity_url')
            
            if not steamid:
                logger.warning(f"玩家配置缺少 steamid: {player}")
                continue
            
            try:
                collector.collect_player_data(steamid, vanity_url)
            except Exception as e:
                logger.error(f"采集玩家 {steamid} 数据时出错: {e}")
                import traceback
                traceback.print_exc()
                continue
        
        logger.info("数据采集完成")
        
    except Exception as e:
        logger.error(f"采集过程出错: {e}")
        import traceback
        traceback.print_exc()
    finally:
        # 关闭数据库连接
        collector.close_db()


if __name__ == '__main__':
    main()

